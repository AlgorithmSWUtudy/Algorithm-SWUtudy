## 삽입정렬(Insertion Sort)
#### [정의]
- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작한다.

#### [로직]
[Step 0] 첫 번째 데이터는 그 자체로 정렬이 되어 있다고 판단하고, 두 번째 데이터가 어떤 위치로
들어갈지 판단한다. 첫번째의 왼쪽으로 들어가거나 오른쪽으로 들어가거나 두 경우만 존재한다.
[Step 1] 세 번째 데이터가 어떤 위치(1번째의 앞 혹은 뒤 2번째의 뒤)로 들어갈지 판단한다.
위 과정을 반복한다.

#### [예제]
```Python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 1씩 감소하며 반복하는 문법
        if array[j] < array[j - 1]: # 한 칸씩 왼쪽으로 이동
            array[j], array[j - 1] = array[j - 1], array[j]
        else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break

print(array)
```

#### [결과]
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

#### [시간복잡도]
O(N²)
* 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다.
* 최선의 경우 O(N)의 시간 복잡도를 가진다.
* 모두 정렬되어 있을 경우에는 한번씩만 비교하기에 O(N)

#### [공간복잡도]
O(N)
- 주어진 배열안에서 교환해 정렬하기 때문에

#### [장점]
- 알고리즘이 단순하다.
- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.
- 선택 정렬이나 버블 정렬에 비하여 상대적으로 빠르다.

#### [단점]
- 비교할 수가 많고 크기가 클 경우에 적합하지 않다.(배열의 길이가 길어질수록 비효율적)
- 평균과 최악의 시간 복잡도가 O(N^2)이므로 비효율적이다.

## [참고 서적 및 사이트]
사이트 : https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Algorithm
서적 : 이것이 취업을 위한 코딩 테스트다 with 파이썬 - 저자 나동빈, 출판 한빛미디어
